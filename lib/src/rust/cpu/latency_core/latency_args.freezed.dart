// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'latency_args.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CacheConfig {
  CacheOptions get il1 => throw _privateConstructorUsedError;
  CacheOptions get dl1 => throw _privateConstructorUsedError;
  CacheOptions get il2 => throw _privateConstructorUsedError;
  CacheOptions get dl2 => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CacheConfigCopyWith<CacheConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CacheConfigCopyWith<$Res> {
  factory $CacheConfigCopyWith(
          CacheConfig value, $Res Function(CacheConfig) then) =
      _$CacheConfigCopyWithImpl<$Res, CacheConfig>;
  @useResult
  $Res call(
      {CacheOptions il1, CacheOptions dl1, CacheOptions il2, CacheOptions dl2});

  $CacheOptionsCopyWith<$Res> get il1;
  $CacheOptionsCopyWith<$Res> get dl1;
  $CacheOptionsCopyWith<$Res> get il2;
  $CacheOptionsCopyWith<$Res> get dl2;
}

/// @nodoc
class _$CacheConfigCopyWithImpl<$Res, $Val extends CacheConfig>
    implements $CacheConfigCopyWith<$Res> {
  _$CacheConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? il1 = null,
    Object? dl1 = null,
    Object? il2 = null,
    Object? dl2 = null,
  }) {
    return _then(_value.copyWith(
      il1: null == il1
          ? _value.il1
          : il1 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
      dl1: null == dl1
          ? _value.dl1
          : dl1 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
      il2: null == il2
          ? _value.il2
          : il2 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
      dl2: null == dl2
          ? _value.dl2
          : dl2 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CacheOptionsCopyWith<$Res> get il1 {
    return $CacheOptionsCopyWith<$Res>(_value.il1, (value) {
      return _then(_value.copyWith(il1: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CacheOptionsCopyWith<$Res> get dl1 {
    return $CacheOptionsCopyWith<$Res>(_value.dl1, (value) {
      return _then(_value.copyWith(dl1: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CacheOptionsCopyWith<$Res> get il2 {
    return $CacheOptionsCopyWith<$Res>(_value.il2, (value) {
      return _then(_value.copyWith(il2: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CacheOptionsCopyWith<$Res> get dl2 {
    return $CacheOptionsCopyWith<$Res>(_value.dl2, (value) {
      return _then(_value.copyWith(dl2: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CacheConfigImplCopyWith<$Res>
    implements $CacheConfigCopyWith<$Res> {
  factory _$$CacheConfigImplCopyWith(
          _$CacheConfigImpl value, $Res Function(_$CacheConfigImpl) then) =
      __$$CacheConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CacheOptions il1, CacheOptions dl1, CacheOptions il2, CacheOptions dl2});

  @override
  $CacheOptionsCopyWith<$Res> get il1;
  @override
  $CacheOptionsCopyWith<$Res> get dl1;
  @override
  $CacheOptionsCopyWith<$Res> get il2;
  @override
  $CacheOptionsCopyWith<$Res> get dl2;
}

/// @nodoc
class __$$CacheConfigImplCopyWithImpl<$Res>
    extends _$CacheConfigCopyWithImpl<$Res, _$CacheConfigImpl>
    implements _$$CacheConfigImplCopyWith<$Res> {
  __$$CacheConfigImplCopyWithImpl(
      _$CacheConfigImpl _value, $Res Function(_$CacheConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? il1 = null,
    Object? dl1 = null,
    Object? il2 = null,
    Object? dl2 = null,
  }) {
    return _then(_$CacheConfigImpl(
      il1: null == il1
          ? _value.il1
          : il1 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
      dl1: null == dl1
          ? _value.dl1
          : dl1 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
      il2: null == il2
          ? _value.il2
          : il2 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
      dl2: null == dl2
          ? _value.dl2
          : dl2 // ignore: cast_nullable_to_non_nullable
              as CacheOptions,
    ));
  }
}

/// @nodoc

class _$CacheConfigImpl implements _CacheConfig {
  const _$CacheConfigImpl(
      {required this.il1,
      required this.dl1,
      required this.il2,
      required this.dl2});

  @override
  final CacheOptions il1;
  @override
  final CacheOptions dl1;
  @override
  final CacheOptions il2;
  @override
  final CacheOptions dl2;

  @override
  String toString() {
    return 'CacheConfig(il1: $il1, dl1: $dl1, il2: $il2, dl2: $dl2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CacheConfigImpl &&
            (identical(other.il1, il1) || other.il1 == il1) &&
            (identical(other.dl1, dl1) || other.dl1 == dl1) &&
            (identical(other.il2, il2) || other.il2 == il2) &&
            (identical(other.dl2, dl2) || other.dl2 == dl2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, il1, dl1, il2, dl2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CacheConfigImplCopyWith<_$CacheConfigImpl> get copyWith =>
      __$$CacheConfigImplCopyWithImpl<_$CacheConfigImpl>(this, _$identity);
}

abstract class _CacheConfig implements CacheConfig {
  const factory _CacheConfig(
      {required final CacheOptions il1,
      required final CacheOptions dl1,
      required final CacheOptions il2,
      required final CacheOptions dl2}) = _$CacheConfigImpl;

  @override
  CacheOptions get il1;
  @override
  CacheOptions get dl1;
  @override
  CacheOptions get il2;
  @override
  CacheOptions get dl2;
  @override
  @JsonKey(ignore: true)
  _$$CacheConfigImplCopyWith<_$CacheConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CommitConfig {
  int? get commitWidth => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CommitConfigCopyWith<CommitConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommitConfigCopyWith<$Res> {
  factory $CommitConfigCopyWith(
          CommitConfig value, $Res Function(CommitConfig) then) =
      _$CommitConfigCopyWithImpl<$Res, CommitConfig>;
  @useResult
  $Res call({int? commitWidth});
}

/// @nodoc
class _$CommitConfigCopyWithImpl<$Res, $Val extends CommitConfig>
    implements $CommitConfigCopyWith<$Res> {
  _$CommitConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? commitWidth = freezed,
  }) {
    return _then(_value.copyWith(
      commitWidth: freezed == commitWidth
          ? _value.commitWidth
          : commitWidth // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CommitConfigImplCopyWith<$Res>
    implements $CommitConfigCopyWith<$Res> {
  factory _$$CommitConfigImplCopyWith(
          _$CommitConfigImpl value, $Res Function(_$CommitConfigImpl) then) =
      __$$CommitConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? commitWidth});
}

/// @nodoc
class __$$CommitConfigImplCopyWithImpl<$Res>
    extends _$CommitConfigCopyWithImpl<$Res, _$CommitConfigImpl>
    implements _$$CommitConfigImplCopyWith<$Res> {
  __$$CommitConfigImplCopyWithImpl(
      _$CommitConfigImpl _value, $Res Function(_$CommitConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? commitWidth = freezed,
  }) {
    return _then(_$CommitConfigImpl(
      commitWidth: freezed == commitWidth
          ? _value.commitWidth
          : commitWidth // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$CommitConfigImpl implements _CommitConfig {
  const _$CommitConfigImpl({this.commitWidth});

  @override
  final int? commitWidth;

  @override
  String toString() {
    return 'CommitConfig(commitWidth: $commitWidth)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommitConfigImpl &&
            (identical(other.commitWidth, commitWidth) ||
                other.commitWidth == commitWidth));
  }

  @override
  int get hashCode => Object.hash(runtimeType, commitWidth);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CommitConfigImplCopyWith<_$CommitConfigImpl> get copyWith =>
      __$$CommitConfigImplCopyWithImpl<_$CommitConfigImpl>(this, _$identity);
}

abstract class _CommitConfig implements CommitConfig {
  const factory _CommitConfig({final int? commitWidth}) = _$CommitConfigImpl;

  @override
  int? get commitWidth;
  @override
  @JsonKey(ignore: true)
  _$$CommitConfigImplCopyWith<_$CommitConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DecodeConfig {
  int? get decodeWidth => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DecodeConfigCopyWith<DecodeConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DecodeConfigCopyWith<$Res> {
  factory $DecodeConfigCopyWith(
          DecodeConfig value, $Res Function(DecodeConfig) then) =
      _$DecodeConfigCopyWithImpl<$Res, DecodeConfig>;
  @useResult
  $Res call({int? decodeWidth});
}

/// @nodoc
class _$DecodeConfigCopyWithImpl<$Res, $Val extends DecodeConfig>
    implements $DecodeConfigCopyWith<$Res> {
  _$DecodeConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? decodeWidth = freezed,
  }) {
    return _then(_value.copyWith(
      decodeWidth: freezed == decodeWidth
          ? _value.decodeWidth
          : decodeWidth // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DecodeConfigImplCopyWith<$Res>
    implements $DecodeConfigCopyWith<$Res> {
  factory _$$DecodeConfigImplCopyWith(
          _$DecodeConfigImpl value, $Res Function(_$DecodeConfigImpl) then) =
      __$$DecodeConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? decodeWidth});
}

/// @nodoc
class __$$DecodeConfigImplCopyWithImpl<$Res>
    extends _$DecodeConfigCopyWithImpl<$Res, _$DecodeConfigImpl>
    implements _$$DecodeConfigImplCopyWith<$Res> {
  __$$DecodeConfigImplCopyWithImpl(
      _$DecodeConfigImpl _value, $Res Function(_$DecodeConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? decodeWidth = freezed,
  }) {
    return _then(_$DecodeConfigImpl(
      decodeWidth: freezed == decodeWidth
          ? _value.decodeWidth
          : decodeWidth // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$DecodeConfigImpl implements _DecodeConfig {
  const _$DecodeConfigImpl({this.decodeWidth});

  @override
  final int? decodeWidth;

  @override
  String toString() {
    return 'DecodeConfig(decodeWidth: $decodeWidth)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecodeConfigImpl &&
            (identical(other.decodeWidth, decodeWidth) ||
                other.decodeWidth == decodeWidth));
  }

  @override
  int get hashCode => Object.hash(runtimeType, decodeWidth);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DecodeConfigImplCopyWith<_$DecodeConfigImpl> get copyWith =>
      __$$DecodeConfigImplCopyWithImpl<_$DecodeConfigImpl>(this, _$identity);
}

abstract class _DecodeConfig implements DecodeConfig {
  const factory _DecodeConfig({final int? decodeWidth}) = _$DecodeConfigImpl;

  @override
  int? get decodeWidth;
  @override
  @JsonKey(ignore: true)
  _$$DecodeConfigImplCopyWith<_$DecodeConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FetchConfig {
  int? get fetchQueueSize => throw _privateConstructorUsedError;
  int? get fetchSpeed => throw _privateConstructorUsedError;
  int? get fetchBranchPenalty => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FetchConfigCopyWith<FetchConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FetchConfigCopyWith<$Res> {
  factory $FetchConfigCopyWith(
          FetchConfig value, $Res Function(FetchConfig) then) =
      _$FetchConfigCopyWithImpl<$Res, FetchConfig>;
  @useResult
  $Res call({int? fetchQueueSize, int? fetchSpeed, int? fetchBranchPenalty});
}

/// @nodoc
class _$FetchConfigCopyWithImpl<$Res, $Val extends FetchConfig>
    implements $FetchConfigCopyWith<$Res> {
  _$FetchConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fetchQueueSize = freezed,
    Object? fetchSpeed = freezed,
    Object? fetchBranchPenalty = freezed,
  }) {
    return _then(_value.copyWith(
      fetchQueueSize: freezed == fetchQueueSize
          ? _value.fetchQueueSize
          : fetchQueueSize // ignore: cast_nullable_to_non_nullable
              as int?,
      fetchSpeed: freezed == fetchSpeed
          ? _value.fetchSpeed
          : fetchSpeed // ignore: cast_nullable_to_non_nullable
              as int?,
      fetchBranchPenalty: freezed == fetchBranchPenalty
          ? _value.fetchBranchPenalty
          : fetchBranchPenalty // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FetchConfigImplCopyWith<$Res>
    implements $FetchConfigCopyWith<$Res> {
  factory _$$FetchConfigImplCopyWith(
          _$FetchConfigImpl value, $Res Function(_$FetchConfigImpl) then) =
      __$$FetchConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? fetchQueueSize, int? fetchSpeed, int? fetchBranchPenalty});
}

/// @nodoc
class __$$FetchConfigImplCopyWithImpl<$Res>
    extends _$FetchConfigCopyWithImpl<$Res, _$FetchConfigImpl>
    implements _$$FetchConfigImplCopyWith<$Res> {
  __$$FetchConfigImplCopyWithImpl(
      _$FetchConfigImpl _value, $Res Function(_$FetchConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fetchQueueSize = freezed,
    Object? fetchSpeed = freezed,
    Object? fetchBranchPenalty = freezed,
  }) {
    return _then(_$FetchConfigImpl(
      fetchQueueSize: freezed == fetchQueueSize
          ? _value.fetchQueueSize
          : fetchQueueSize // ignore: cast_nullable_to_non_nullable
              as int?,
      fetchSpeed: freezed == fetchSpeed
          ? _value.fetchSpeed
          : fetchSpeed // ignore: cast_nullable_to_non_nullable
              as int?,
      fetchBranchPenalty: freezed == fetchBranchPenalty
          ? _value.fetchBranchPenalty
          : fetchBranchPenalty // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$FetchConfigImpl implements _FetchConfig {
  const _$FetchConfigImpl(
      {this.fetchQueueSize, this.fetchSpeed, this.fetchBranchPenalty});

  @override
  final int? fetchQueueSize;
  @override
  final int? fetchSpeed;
  @override
  final int? fetchBranchPenalty;

  @override
  String toString() {
    return 'FetchConfig(fetchQueueSize: $fetchQueueSize, fetchSpeed: $fetchSpeed, fetchBranchPenalty: $fetchBranchPenalty)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchConfigImpl &&
            (identical(other.fetchQueueSize, fetchQueueSize) ||
                other.fetchQueueSize == fetchQueueSize) &&
            (identical(other.fetchSpeed, fetchSpeed) ||
                other.fetchSpeed == fetchSpeed) &&
            (identical(other.fetchBranchPenalty, fetchBranchPenalty) ||
                other.fetchBranchPenalty == fetchBranchPenalty));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, fetchQueueSize, fetchSpeed, fetchBranchPenalty);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchConfigImplCopyWith<_$FetchConfigImpl> get copyWith =>
      __$$FetchConfigImplCopyWithImpl<_$FetchConfigImpl>(this, _$identity);
}

abstract class _FetchConfig implements FetchConfig {
  const factory _FetchConfig(
      {final int? fetchQueueSize,
      final int? fetchSpeed,
      final int? fetchBranchPenalty}) = _$FetchConfigImpl;

  @override
  int? get fetchQueueSize;
  @override
  int? get fetchSpeed;
  @override
  int? get fetchBranchPenalty;
  @override
  @JsonKey(ignore: true)
  _$$FetchConfigImplCopyWith<_$FetchConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FunctionalUnitPoolConfig {
  FunctionalUnitGroupCfg get ialu => throw _privateConstructorUsedError;
  FunctionalUnitGroupCfg get imult => throw _privateConstructorUsedError;
  FunctionalUnitGroupCfg get idiv => throw _privateConstructorUsedError;
  FunctionalUnitGroupCfg get load => throw _privateConstructorUsedError;
  FunctionalUnitGroupCfg get store => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FunctionalUnitPoolConfigCopyWith<FunctionalUnitPoolConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FunctionalUnitPoolConfigCopyWith<$Res> {
  factory $FunctionalUnitPoolConfigCopyWith(FunctionalUnitPoolConfig value,
          $Res Function(FunctionalUnitPoolConfig) then) =
      _$FunctionalUnitPoolConfigCopyWithImpl<$Res, FunctionalUnitPoolConfig>;
  @useResult
  $Res call(
      {FunctionalUnitGroupCfg ialu,
      FunctionalUnitGroupCfg imult,
      FunctionalUnitGroupCfg idiv,
      FunctionalUnitGroupCfg load,
      FunctionalUnitGroupCfg store});

  $FunctionalUnitGroupCfgCopyWith<$Res> get ialu;
  $FunctionalUnitGroupCfgCopyWith<$Res> get imult;
  $FunctionalUnitGroupCfgCopyWith<$Res> get idiv;
  $FunctionalUnitGroupCfgCopyWith<$Res> get load;
  $FunctionalUnitGroupCfgCopyWith<$Res> get store;
}

/// @nodoc
class _$FunctionalUnitPoolConfigCopyWithImpl<$Res,
        $Val extends FunctionalUnitPoolConfig>
    implements $FunctionalUnitPoolConfigCopyWith<$Res> {
  _$FunctionalUnitPoolConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ialu = null,
    Object? imult = null,
    Object? idiv = null,
    Object? load = null,
    Object? store = null,
  }) {
    return _then(_value.copyWith(
      ialu: null == ialu
          ? _value.ialu
          : ialu // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      imult: null == imult
          ? _value.imult
          : imult // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      idiv: null == idiv
          ? _value.idiv
          : idiv // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      load: null == load
          ? _value.load
          : load // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionalUnitGroupCfgCopyWith<$Res> get ialu {
    return $FunctionalUnitGroupCfgCopyWith<$Res>(_value.ialu, (value) {
      return _then(_value.copyWith(ialu: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionalUnitGroupCfgCopyWith<$Res> get imult {
    return $FunctionalUnitGroupCfgCopyWith<$Res>(_value.imult, (value) {
      return _then(_value.copyWith(imult: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionalUnitGroupCfgCopyWith<$Res> get idiv {
    return $FunctionalUnitGroupCfgCopyWith<$Res>(_value.idiv, (value) {
      return _then(_value.copyWith(idiv: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionalUnitGroupCfgCopyWith<$Res> get load {
    return $FunctionalUnitGroupCfgCopyWith<$Res>(_value.load, (value) {
      return _then(_value.copyWith(load: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionalUnitGroupCfgCopyWith<$Res> get store {
    return $FunctionalUnitGroupCfgCopyWith<$Res>(_value.store, (value) {
      return _then(_value.copyWith(store: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$FunctionalUnitPoolConfigImplCopyWith<$Res>
    implements $FunctionalUnitPoolConfigCopyWith<$Res> {
  factory _$$FunctionalUnitPoolConfigImplCopyWith(
          _$FunctionalUnitPoolConfigImpl value,
          $Res Function(_$FunctionalUnitPoolConfigImpl) then) =
      __$$FunctionalUnitPoolConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {FunctionalUnitGroupCfg ialu,
      FunctionalUnitGroupCfg imult,
      FunctionalUnitGroupCfg idiv,
      FunctionalUnitGroupCfg load,
      FunctionalUnitGroupCfg store});

  @override
  $FunctionalUnitGroupCfgCopyWith<$Res> get ialu;
  @override
  $FunctionalUnitGroupCfgCopyWith<$Res> get imult;
  @override
  $FunctionalUnitGroupCfgCopyWith<$Res> get idiv;
  @override
  $FunctionalUnitGroupCfgCopyWith<$Res> get load;
  @override
  $FunctionalUnitGroupCfgCopyWith<$Res> get store;
}

/// @nodoc
class __$$FunctionalUnitPoolConfigImplCopyWithImpl<$Res>
    extends _$FunctionalUnitPoolConfigCopyWithImpl<$Res,
        _$FunctionalUnitPoolConfigImpl>
    implements _$$FunctionalUnitPoolConfigImplCopyWith<$Res> {
  __$$FunctionalUnitPoolConfigImplCopyWithImpl(
      _$FunctionalUnitPoolConfigImpl _value,
      $Res Function(_$FunctionalUnitPoolConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ialu = null,
    Object? imult = null,
    Object? idiv = null,
    Object? load = null,
    Object? store = null,
  }) {
    return _then(_$FunctionalUnitPoolConfigImpl(
      ialu: null == ialu
          ? _value.ialu
          : ialu // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      imult: null == imult
          ? _value.imult
          : imult // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      idiv: null == idiv
          ? _value.idiv
          : idiv // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      load: null == load
          ? _value.load
          : load // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitGroupCfg,
    ));
  }
}

/// @nodoc

class _$FunctionalUnitPoolConfigImpl implements _FunctionalUnitPoolConfig {
  const _$FunctionalUnitPoolConfigImpl(
      {required this.ialu,
      required this.imult,
      required this.idiv,
      required this.load,
      required this.store});

  @override
  final FunctionalUnitGroupCfg ialu;
  @override
  final FunctionalUnitGroupCfg imult;
  @override
  final FunctionalUnitGroupCfg idiv;
  @override
  final FunctionalUnitGroupCfg load;
  @override
  final FunctionalUnitGroupCfg store;

  @override
  String toString() {
    return 'FunctionalUnitPoolConfig(ialu: $ialu, imult: $imult, idiv: $idiv, load: $load, store: $store)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FunctionalUnitPoolConfigImpl &&
            (identical(other.ialu, ialu) || other.ialu == ialu) &&
            (identical(other.imult, imult) || other.imult == imult) &&
            (identical(other.idiv, idiv) || other.idiv == idiv) &&
            (identical(other.load, load) || other.load == load) &&
            (identical(other.store, store) || other.store == store));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ialu, imult, idiv, load, store);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FunctionalUnitPoolConfigImplCopyWith<_$FunctionalUnitPoolConfigImpl>
      get copyWith => __$$FunctionalUnitPoolConfigImplCopyWithImpl<
          _$FunctionalUnitPoolConfigImpl>(this, _$identity);
}

abstract class _FunctionalUnitPoolConfig implements FunctionalUnitPoolConfig {
  const factory _FunctionalUnitPoolConfig(
          {required final FunctionalUnitGroupCfg ialu,
          required final FunctionalUnitGroupCfg imult,
          required final FunctionalUnitGroupCfg idiv,
          required final FunctionalUnitGroupCfg load,
          required final FunctionalUnitGroupCfg store}) =
      _$FunctionalUnitPoolConfigImpl;

  @override
  FunctionalUnitGroupCfg get ialu;
  @override
  FunctionalUnitGroupCfg get imult;
  @override
  FunctionalUnitGroupCfg get idiv;
  @override
  FunctionalUnitGroupCfg get load;
  @override
  FunctionalUnitGroupCfg get store;
  @override
  @JsonKey(ignore: true)
  _$$FunctionalUnitPoolConfigImplCopyWith<_$FunctionalUnitPoolConfigImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$IssueConfig {
  int? get issueWidth => throw _privateConstructorUsedError;
  IssueOrder get issueOrder => throw _privateConstructorUsedError;
  bool get issueNoMisspec => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $IssueConfigCopyWith<IssueConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IssueConfigCopyWith<$Res> {
  factory $IssueConfigCopyWith(
          IssueConfig value, $Res Function(IssueConfig) then) =
      _$IssueConfigCopyWithImpl<$Res, IssueConfig>;
  @useResult
  $Res call({int? issueWidth, IssueOrder issueOrder, bool issueNoMisspec});
}

/// @nodoc
class _$IssueConfigCopyWithImpl<$Res, $Val extends IssueConfig>
    implements $IssueConfigCopyWith<$Res> {
  _$IssueConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? issueWidth = freezed,
    Object? issueOrder = null,
    Object? issueNoMisspec = null,
  }) {
    return _then(_value.copyWith(
      issueWidth: freezed == issueWidth
          ? _value.issueWidth
          : issueWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      issueOrder: null == issueOrder
          ? _value.issueOrder
          : issueOrder // ignore: cast_nullable_to_non_nullable
              as IssueOrder,
      issueNoMisspec: null == issueNoMisspec
          ? _value.issueNoMisspec
          : issueNoMisspec // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IssueConfigImplCopyWith<$Res>
    implements $IssueConfigCopyWith<$Res> {
  factory _$$IssueConfigImplCopyWith(
          _$IssueConfigImpl value, $Res Function(_$IssueConfigImpl) then) =
      __$$IssueConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? issueWidth, IssueOrder issueOrder, bool issueNoMisspec});
}

/// @nodoc
class __$$IssueConfigImplCopyWithImpl<$Res>
    extends _$IssueConfigCopyWithImpl<$Res, _$IssueConfigImpl>
    implements _$$IssueConfigImplCopyWith<$Res> {
  __$$IssueConfigImplCopyWithImpl(
      _$IssueConfigImpl _value, $Res Function(_$IssueConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? issueWidth = freezed,
    Object? issueOrder = null,
    Object? issueNoMisspec = null,
  }) {
    return _then(_$IssueConfigImpl(
      issueWidth: freezed == issueWidth
          ? _value.issueWidth
          : issueWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      issueOrder: null == issueOrder
          ? _value.issueOrder
          : issueOrder // ignore: cast_nullable_to_non_nullable
              as IssueOrder,
      issueNoMisspec: null == issueNoMisspec
          ? _value.issueNoMisspec
          : issueNoMisspec // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$IssueConfigImpl implements _IssueConfig {
  const _$IssueConfigImpl(
      {this.issueWidth,
      required this.issueOrder,
      required this.issueNoMisspec});

  @override
  final int? issueWidth;
  @override
  final IssueOrder issueOrder;
  @override
  final bool issueNoMisspec;

  @override
  String toString() {
    return 'IssueConfig(issueWidth: $issueWidth, issueOrder: $issueOrder, issueNoMisspec: $issueNoMisspec)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IssueConfigImpl &&
            (identical(other.issueWidth, issueWidth) ||
                other.issueWidth == issueWidth) &&
            (identical(other.issueOrder, issueOrder) ||
                other.issueOrder == issueOrder) &&
            (identical(other.issueNoMisspec, issueNoMisspec) ||
                other.issueNoMisspec == issueNoMisspec));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, issueWidth, issueOrder, issueNoMisspec);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IssueConfigImplCopyWith<_$IssueConfigImpl> get copyWith =>
      __$$IssueConfigImplCopyWithImpl<_$IssueConfigImpl>(this, _$identity);
}

abstract class _IssueConfig implements IssueConfig {
  const factory _IssueConfig(
      {final int? issueWidth,
      required final IssueOrder issueOrder,
      required final bool issueNoMisspec}) = _$IssueConfigImpl;

  @override
  int? get issueWidth;
  @override
  IssueOrder get issueOrder;
  @override
  bool get issueNoMisspec;
  @override
  @JsonKey(ignore: true)
  _$$IssueConfigImplCopyWith<_$IssueConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LatencyArgs {
  String get binaryPath => throw _privateConstructorUsedError;
  int? get rsqSize => throw _privateConstructorUsedError;
  int? get lsqSize => throw _privateConstructorUsedError;
  RunConfig get runConfig => throw _privateConstructorUsedError;
  FetchConfig get fetchConfig => throw _privateConstructorUsedError;
  DecodeConfig get decodeConfig => throw _privateConstructorUsedError;
  IssueConfig get issueConfig => throw _privateConstructorUsedError;
  CommitConfig get commitConfig => throw _privateConstructorUsedError;
  FunctionalUnitPoolConfig get functionalUnitPoolConfig =>
      throw _privateConstructorUsedError;
  MemoryConfig get memoryConfig => throw _privateConstructorUsedError;
  CacheConfig get cacheConfig => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LatencyArgsCopyWith<LatencyArgs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LatencyArgsCopyWith<$Res> {
  factory $LatencyArgsCopyWith(
          LatencyArgs value, $Res Function(LatencyArgs) then) =
      _$LatencyArgsCopyWithImpl<$Res, LatencyArgs>;
  @useResult
  $Res call(
      {String binaryPath,
      int? rsqSize,
      int? lsqSize,
      RunConfig runConfig,
      FetchConfig fetchConfig,
      DecodeConfig decodeConfig,
      IssueConfig issueConfig,
      CommitConfig commitConfig,
      FunctionalUnitPoolConfig functionalUnitPoolConfig,
      MemoryConfig memoryConfig,
      CacheConfig cacheConfig});

  $RunConfigCopyWith<$Res> get runConfig;
  $FetchConfigCopyWith<$Res> get fetchConfig;
  $DecodeConfigCopyWith<$Res> get decodeConfig;
  $IssueConfigCopyWith<$Res> get issueConfig;
  $CommitConfigCopyWith<$Res> get commitConfig;
  $FunctionalUnitPoolConfigCopyWith<$Res> get functionalUnitPoolConfig;
  $MemoryConfigCopyWith<$Res> get memoryConfig;
  $CacheConfigCopyWith<$Res> get cacheConfig;
}

/// @nodoc
class _$LatencyArgsCopyWithImpl<$Res, $Val extends LatencyArgs>
    implements $LatencyArgsCopyWith<$Res> {
  _$LatencyArgsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? binaryPath = null,
    Object? rsqSize = freezed,
    Object? lsqSize = freezed,
    Object? runConfig = null,
    Object? fetchConfig = null,
    Object? decodeConfig = null,
    Object? issueConfig = null,
    Object? commitConfig = null,
    Object? functionalUnitPoolConfig = null,
    Object? memoryConfig = null,
    Object? cacheConfig = null,
  }) {
    return _then(_value.copyWith(
      binaryPath: null == binaryPath
          ? _value.binaryPath
          : binaryPath // ignore: cast_nullable_to_non_nullable
              as String,
      rsqSize: freezed == rsqSize
          ? _value.rsqSize
          : rsqSize // ignore: cast_nullable_to_non_nullable
              as int?,
      lsqSize: freezed == lsqSize
          ? _value.lsqSize
          : lsqSize // ignore: cast_nullable_to_non_nullable
              as int?,
      runConfig: null == runConfig
          ? _value.runConfig
          : runConfig // ignore: cast_nullable_to_non_nullable
              as RunConfig,
      fetchConfig: null == fetchConfig
          ? _value.fetchConfig
          : fetchConfig // ignore: cast_nullable_to_non_nullable
              as FetchConfig,
      decodeConfig: null == decodeConfig
          ? _value.decodeConfig
          : decodeConfig // ignore: cast_nullable_to_non_nullable
              as DecodeConfig,
      issueConfig: null == issueConfig
          ? _value.issueConfig
          : issueConfig // ignore: cast_nullable_to_non_nullable
              as IssueConfig,
      commitConfig: null == commitConfig
          ? _value.commitConfig
          : commitConfig // ignore: cast_nullable_to_non_nullable
              as CommitConfig,
      functionalUnitPoolConfig: null == functionalUnitPoolConfig
          ? _value.functionalUnitPoolConfig
          : functionalUnitPoolConfig // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitPoolConfig,
      memoryConfig: null == memoryConfig
          ? _value.memoryConfig
          : memoryConfig // ignore: cast_nullable_to_non_nullable
              as MemoryConfig,
      cacheConfig: null == cacheConfig
          ? _value.cacheConfig
          : cacheConfig // ignore: cast_nullable_to_non_nullable
              as CacheConfig,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RunConfigCopyWith<$Res> get runConfig {
    return $RunConfigCopyWith<$Res>(_value.runConfig, (value) {
      return _then(_value.copyWith(runConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FetchConfigCopyWith<$Res> get fetchConfig {
    return $FetchConfigCopyWith<$Res>(_value.fetchConfig, (value) {
      return _then(_value.copyWith(fetchConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DecodeConfigCopyWith<$Res> get decodeConfig {
    return $DecodeConfigCopyWith<$Res>(_value.decodeConfig, (value) {
      return _then(_value.copyWith(decodeConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IssueConfigCopyWith<$Res> get issueConfig {
    return $IssueConfigCopyWith<$Res>(_value.issueConfig, (value) {
      return _then(_value.copyWith(issueConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CommitConfigCopyWith<$Res> get commitConfig {
    return $CommitConfigCopyWith<$Res>(_value.commitConfig, (value) {
      return _then(_value.copyWith(commitConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FunctionalUnitPoolConfigCopyWith<$Res> get functionalUnitPoolConfig {
    return $FunctionalUnitPoolConfigCopyWith<$Res>(
        _value.functionalUnitPoolConfig, (value) {
      return _then(_value.copyWith(functionalUnitPoolConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MemoryConfigCopyWith<$Res> get memoryConfig {
    return $MemoryConfigCopyWith<$Res>(_value.memoryConfig, (value) {
      return _then(_value.copyWith(memoryConfig: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CacheConfigCopyWith<$Res> get cacheConfig {
    return $CacheConfigCopyWith<$Res>(_value.cacheConfig, (value) {
      return _then(_value.copyWith(cacheConfig: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LatencyArgsImplCopyWith<$Res>
    implements $LatencyArgsCopyWith<$Res> {
  factory _$$LatencyArgsImplCopyWith(
          _$LatencyArgsImpl value, $Res Function(_$LatencyArgsImpl) then) =
      __$$LatencyArgsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String binaryPath,
      int? rsqSize,
      int? lsqSize,
      RunConfig runConfig,
      FetchConfig fetchConfig,
      DecodeConfig decodeConfig,
      IssueConfig issueConfig,
      CommitConfig commitConfig,
      FunctionalUnitPoolConfig functionalUnitPoolConfig,
      MemoryConfig memoryConfig,
      CacheConfig cacheConfig});

  @override
  $RunConfigCopyWith<$Res> get runConfig;
  @override
  $FetchConfigCopyWith<$Res> get fetchConfig;
  @override
  $DecodeConfigCopyWith<$Res> get decodeConfig;
  @override
  $IssueConfigCopyWith<$Res> get issueConfig;
  @override
  $CommitConfigCopyWith<$Res> get commitConfig;
  @override
  $FunctionalUnitPoolConfigCopyWith<$Res> get functionalUnitPoolConfig;
  @override
  $MemoryConfigCopyWith<$Res> get memoryConfig;
  @override
  $CacheConfigCopyWith<$Res> get cacheConfig;
}

/// @nodoc
class __$$LatencyArgsImplCopyWithImpl<$Res>
    extends _$LatencyArgsCopyWithImpl<$Res, _$LatencyArgsImpl>
    implements _$$LatencyArgsImplCopyWith<$Res> {
  __$$LatencyArgsImplCopyWithImpl(
      _$LatencyArgsImpl _value, $Res Function(_$LatencyArgsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? binaryPath = null,
    Object? rsqSize = freezed,
    Object? lsqSize = freezed,
    Object? runConfig = null,
    Object? fetchConfig = null,
    Object? decodeConfig = null,
    Object? issueConfig = null,
    Object? commitConfig = null,
    Object? functionalUnitPoolConfig = null,
    Object? memoryConfig = null,
    Object? cacheConfig = null,
  }) {
    return _then(_$LatencyArgsImpl(
      binaryPath: null == binaryPath
          ? _value.binaryPath
          : binaryPath // ignore: cast_nullable_to_non_nullable
              as String,
      rsqSize: freezed == rsqSize
          ? _value.rsqSize
          : rsqSize // ignore: cast_nullable_to_non_nullable
              as int?,
      lsqSize: freezed == lsqSize
          ? _value.lsqSize
          : lsqSize // ignore: cast_nullable_to_non_nullable
              as int?,
      runConfig: null == runConfig
          ? _value.runConfig
          : runConfig // ignore: cast_nullable_to_non_nullable
              as RunConfig,
      fetchConfig: null == fetchConfig
          ? _value.fetchConfig
          : fetchConfig // ignore: cast_nullable_to_non_nullable
              as FetchConfig,
      decodeConfig: null == decodeConfig
          ? _value.decodeConfig
          : decodeConfig // ignore: cast_nullable_to_non_nullable
              as DecodeConfig,
      issueConfig: null == issueConfig
          ? _value.issueConfig
          : issueConfig // ignore: cast_nullable_to_non_nullable
              as IssueConfig,
      commitConfig: null == commitConfig
          ? _value.commitConfig
          : commitConfig // ignore: cast_nullable_to_non_nullable
              as CommitConfig,
      functionalUnitPoolConfig: null == functionalUnitPoolConfig
          ? _value.functionalUnitPoolConfig
          : functionalUnitPoolConfig // ignore: cast_nullable_to_non_nullable
              as FunctionalUnitPoolConfig,
      memoryConfig: null == memoryConfig
          ? _value.memoryConfig
          : memoryConfig // ignore: cast_nullable_to_non_nullable
              as MemoryConfig,
      cacheConfig: null == cacheConfig
          ? _value.cacheConfig
          : cacheConfig // ignore: cast_nullable_to_non_nullable
              as CacheConfig,
    ));
  }
}

/// @nodoc

class _$LatencyArgsImpl implements _LatencyArgs {
  const _$LatencyArgsImpl(
      {required this.binaryPath,
      this.rsqSize,
      this.lsqSize,
      required this.runConfig,
      required this.fetchConfig,
      required this.decodeConfig,
      required this.issueConfig,
      required this.commitConfig,
      required this.functionalUnitPoolConfig,
      required this.memoryConfig,
      required this.cacheConfig});

  @override
  final String binaryPath;
  @override
  final int? rsqSize;
  @override
  final int? lsqSize;
  @override
  final RunConfig runConfig;
  @override
  final FetchConfig fetchConfig;
  @override
  final DecodeConfig decodeConfig;
  @override
  final IssueConfig issueConfig;
  @override
  final CommitConfig commitConfig;
  @override
  final FunctionalUnitPoolConfig functionalUnitPoolConfig;
  @override
  final MemoryConfig memoryConfig;
  @override
  final CacheConfig cacheConfig;

  @override
  String toString() {
    return 'LatencyArgs(binaryPath: $binaryPath, rsqSize: $rsqSize, lsqSize: $lsqSize, runConfig: $runConfig, fetchConfig: $fetchConfig, decodeConfig: $decodeConfig, issueConfig: $issueConfig, commitConfig: $commitConfig, functionalUnitPoolConfig: $functionalUnitPoolConfig, memoryConfig: $memoryConfig, cacheConfig: $cacheConfig)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LatencyArgsImpl &&
            (identical(other.binaryPath, binaryPath) ||
                other.binaryPath == binaryPath) &&
            (identical(other.rsqSize, rsqSize) || other.rsqSize == rsqSize) &&
            (identical(other.lsqSize, lsqSize) || other.lsqSize == lsqSize) &&
            (identical(other.runConfig, runConfig) ||
                other.runConfig == runConfig) &&
            (identical(other.fetchConfig, fetchConfig) ||
                other.fetchConfig == fetchConfig) &&
            (identical(other.decodeConfig, decodeConfig) ||
                other.decodeConfig == decodeConfig) &&
            (identical(other.issueConfig, issueConfig) ||
                other.issueConfig == issueConfig) &&
            (identical(other.commitConfig, commitConfig) ||
                other.commitConfig == commitConfig) &&
            (identical(
                    other.functionalUnitPoolConfig, functionalUnitPoolConfig) ||
                other.functionalUnitPoolConfig == functionalUnitPoolConfig) &&
            (identical(other.memoryConfig, memoryConfig) ||
                other.memoryConfig == memoryConfig) &&
            (identical(other.cacheConfig, cacheConfig) ||
                other.cacheConfig == cacheConfig));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      binaryPath,
      rsqSize,
      lsqSize,
      runConfig,
      fetchConfig,
      decodeConfig,
      issueConfig,
      commitConfig,
      functionalUnitPoolConfig,
      memoryConfig,
      cacheConfig);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LatencyArgsImplCopyWith<_$LatencyArgsImpl> get copyWith =>
      __$$LatencyArgsImplCopyWithImpl<_$LatencyArgsImpl>(this, _$identity);
}

abstract class _LatencyArgs implements LatencyArgs {
  const factory _LatencyArgs(
      {required final String binaryPath,
      final int? rsqSize,
      final int? lsqSize,
      required final RunConfig runConfig,
      required final FetchConfig fetchConfig,
      required final DecodeConfig decodeConfig,
      required final IssueConfig issueConfig,
      required final CommitConfig commitConfig,
      required final FunctionalUnitPoolConfig functionalUnitPoolConfig,
      required final MemoryConfig memoryConfig,
      required final CacheConfig cacheConfig}) = _$LatencyArgsImpl;

  @override
  String get binaryPath;
  @override
  int? get rsqSize;
  @override
  int? get lsqSize;
  @override
  RunConfig get runConfig;
  @override
  FetchConfig get fetchConfig;
  @override
  DecodeConfig get decodeConfig;
  @override
  IssueConfig get issueConfig;
  @override
  CommitConfig get commitConfig;
  @override
  FunctionalUnitPoolConfig get functionalUnitPoolConfig;
  @override
  MemoryConfig get memoryConfig;
  @override
  CacheConfig get cacheConfig;
  @override
  @JsonKey(ignore: true)
  _$$LatencyArgsImplCopyWith<_$LatencyArgsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MemoryConfig {
  int get memoryBusWidth => throw _privateConstructorUsedError;
  Uint64List? get memoryLatency => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MemoryConfigCopyWith<MemoryConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MemoryConfigCopyWith<$Res> {
  factory $MemoryConfigCopyWith(
          MemoryConfig value, $Res Function(MemoryConfig) then) =
      _$MemoryConfigCopyWithImpl<$Res, MemoryConfig>;
  @useResult
  $Res call({int memoryBusWidth, Uint64List? memoryLatency});
}

/// @nodoc
class _$MemoryConfigCopyWithImpl<$Res, $Val extends MemoryConfig>
    implements $MemoryConfigCopyWith<$Res> {
  _$MemoryConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? memoryBusWidth = null,
    Object? memoryLatency = freezed,
  }) {
    return _then(_value.copyWith(
      memoryBusWidth: null == memoryBusWidth
          ? _value.memoryBusWidth
          : memoryBusWidth // ignore: cast_nullable_to_non_nullable
              as int,
      memoryLatency: freezed == memoryLatency
          ? _value.memoryLatency
          : memoryLatency // ignore: cast_nullable_to_non_nullable
              as Uint64List?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MemoryConfigImplCopyWith<$Res>
    implements $MemoryConfigCopyWith<$Res> {
  factory _$$MemoryConfigImplCopyWith(
          _$MemoryConfigImpl value, $Res Function(_$MemoryConfigImpl) then) =
      __$$MemoryConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int memoryBusWidth, Uint64List? memoryLatency});
}

/// @nodoc
class __$$MemoryConfigImplCopyWithImpl<$Res>
    extends _$MemoryConfigCopyWithImpl<$Res, _$MemoryConfigImpl>
    implements _$$MemoryConfigImplCopyWith<$Res> {
  __$$MemoryConfigImplCopyWithImpl(
      _$MemoryConfigImpl _value, $Res Function(_$MemoryConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? memoryBusWidth = null,
    Object? memoryLatency = freezed,
  }) {
    return _then(_$MemoryConfigImpl(
      memoryBusWidth: null == memoryBusWidth
          ? _value.memoryBusWidth
          : memoryBusWidth // ignore: cast_nullable_to_non_nullable
              as int,
      memoryLatency: freezed == memoryLatency
          ? _value.memoryLatency
          : memoryLatency // ignore: cast_nullable_to_non_nullable
              as Uint64List?,
    ));
  }
}

/// @nodoc

class _$MemoryConfigImpl implements _MemoryConfig {
  const _$MemoryConfigImpl({required this.memoryBusWidth, this.memoryLatency});

  @override
  final int memoryBusWidth;
  @override
  final Uint64List? memoryLatency;

  @override
  String toString() {
    return 'MemoryConfig(memoryBusWidth: $memoryBusWidth, memoryLatency: $memoryLatency)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MemoryConfigImpl &&
            (identical(other.memoryBusWidth, memoryBusWidth) ||
                other.memoryBusWidth == memoryBusWidth) &&
            const DeepCollectionEquality()
                .equals(other.memoryLatency, memoryLatency));
  }

  @override
  int get hashCode => Object.hash(runtimeType, memoryBusWidth,
      const DeepCollectionEquality().hash(memoryLatency));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MemoryConfigImplCopyWith<_$MemoryConfigImpl> get copyWith =>
      __$$MemoryConfigImplCopyWithImpl<_$MemoryConfigImpl>(this, _$identity);
}

abstract class _MemoryConfig implements MemoryConfig {
  const factory _MemoryConfig(
      {required final int memoryBusWidth,
      final Uint64List? memoryLatency}) = _$MemoryConfigImpl;

  @override
  int get memoryBusWidth;
  @override
  Uint64List? get memoryLatency;
  @override
  @JsonKey(ignore: true)
  _$$MemoryConfigImplCopyWith<_$MemoryConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RunConfig {
  int? get fastForward => throw _privateConstructorUsedError;
  int? get maxInstrs => throw _privateConstructorUsedError;
  Uint64List? get statInterval => throw _privateConstructorUsedError;
  int? get statFreq => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RunConfigCopyWith<RunConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RunConfigCopyWith<$Res> {
  factory $RunConfigCopyWith(RunConfig value, $Res Function(RunConfig) then) =
      _$RunConfigCopyWithImpl<$Res, RunConfig>;
  @useResult
  $Res call(
      {int? fastForward,
      int? maxInstrs,
      Uint64List? statInterval,
      int? statFreq});
}

/// @nodoc
class _$RunConfigCopyWithImpl<$Res, $Val extends RunConfig>
    implements $RunConfigCopyWith<$Res> {
  _$RunConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fastForward = freezed,
    Object? maxInstrs = freezed,
    Object? statInterval = freezed,
    Object? statFreq = freezed,
  }) {
    return _then(_value.copyWith(
      fastForward: freezed == fastForward
          ? _value.fastForward
          : fastForward // ignore: cast_nullable_to_non_nullable
              as int?,
      maxInstrs: freezed == maxInstrs
          ? _value.maxInstrs
          : maxInstrs // ignore: cast_nullable_to_non_nullable
              as int?,
      statInterval: freezed == statInterval
          ? _value.statInterval
          : statInterval // ignore: cast_nullable_to_non_nullable
              as Uint64List?,
      statFreq: freezed == statFreq
          ? _value.statFreq
          : statFreq // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RunConfigImplCopyWith<$Res>
    implements $RunConfigCopyWith<$Res> {
  factory _$$RunConfigImplCopyWith(
          _$RunConfigImpl value, $Res Function(_$RunConfigImpl) then) =
      __$$RunConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? fastForward,
      int? maxInstrs,
      Uint64List? statInterval,
      int? statFreq});
}

/// @nodoc
class __$$RunConfigImplCopyWithImpl<$Res>
    extends _$RunConfigCopyWithImpl<$Res, _$RunConfigImpl>
    implements _$$RunConfigImplCopyWith<$Res> {
  __$$RunConfigImplCopyWithImpl(
      _$RunConfigImpl _value, $Res Function(_$RunConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fastForward = freezed,
    Object? maxInstrs = freezed,
    Object? statInterval = freezed,
    Object? statFreq = freezed,
  }) {
    return _then(_$RunConfigImpl(
      fastForward: freezed == fastForward
          ? _value.fastForward
          : fastForward // ignore: cast_nullable_to_non_nullable
              as int?,
      maxInstrs: freezed == maxInstrs
          ? _value.maxInstrs
          : maxInstrs // ignore: cast_nullable_to_non_nullable
              as int?,
      statInterval: freezed == statInterval
          ? _value.statInterval
          : statInterval // ignore: cast_nullable_to_non_nullable
              as Uint64List?,
      statFreq: freezed == statFreq
          ? _value.statFreq
          : statFreq // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$RunConfigImpl implements _RunConfig {
  const _$RunConfigImpl(
      {this.fastForward, this.maxInstrs, this.statInterval, this.statFreq});

  @override
  final int? fastForward;
  @override
  final int? maxInstrs;
  @override
  final Uint64List? statInterval;
  @override
  final int? statFreq;

  @override
  String toString() {
    return 'RunConfig(fastForward: $fastForward, maxInstrs: $maxInstrs, statInterval: $statInterval, statFreq: $statFreq)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RunConfigImpl &&
            (identical(other.fastForward, fastForward) ||
                other.fastForward == fastForward) &&
            (identical(other.maxInstrs, maxInstrs) ||
                other.maxInstrs == maxInstrs) &&
            const DeepCollectionEquality()
                .equals(other.statInterval, statInterval) &&
            (identical(other.statFreq, statFreq) ||
                other.statFreq == statFreq));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fastForward, maxInstrs,
      const DeepCollectionEquality().hash(statInterval), statFreq);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RunConfigImplCopyWith<_$RunConfigImpl> get copyWith =>
      __$$RunConfigImplCopyWithImpl<_$RunConfigImpl>(this, _$identity);
}

abstract class _RunConfig implements RunConfig {
  const factory _RunConfig(
      {final int? fastForward,
      final int? maxInstrs,
      final Uint64List? statInterval,
      final int? statFreq}) = _$RunConfigImpl;

  @override
  int? get fastForward;
  @override
  int? get maxInstrs;
  @override
  Uint64List? get statInterval;
  @override
  int? get statFreq;
  @override
  @JsonKey(ignore: true)
  _$$RunConfigImplCopyWith<_$RunConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
